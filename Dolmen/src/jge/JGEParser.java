package jge;

import org.eclipse.jdt.annotation.Nullable;
import org.eclipse.jdt.annotation.NonNull;
import java.util.List;
import java.util.ArrayList;
import common.Lists;
import syntax.Extent;
import syntax.Located;
import syntax.Production;
import syntax.Option;
import syntax.Grammar.TokenDecl;
import syntax.GrammarRule;
import syntax.Grammar;
/**
 * Parser generated by Dolmen 
 */
@SuppressWarnings("javadoc")
@org.eclipse.jdt.annotation.NonNullByDefault({})
public final class JGEParser extends codegen.BaseParser<JGEParser.Token> {
    
    public static abstract class Token {
        
        public enum Kind {
            IDENT,
            ACTION,
            ARGUMENTS,
            STRING,
            EQUAL,
            LSQUARE,
            RSQUARE,
            BAR,
            DOT,
            STAR,
            SEMICOL,
            IMPORT,
            STATIC,
            PUBLIC,
            PRIVATE,
            TOKEN,
            RULE,
            EOF;
        }
        
        private Token()  {
            // nothing to do
        }
        
        @Override
        public abstract String toString();
        
        public abstract Kind getKind();
        
        public final static class IDENT extends Token {
            public final @NonNull String value;
            
            private IDENT(@NonNull String value) {
                this.value = value;
            }
            
            @Override
            public String toString() {
                return "IDENT(" + value + ")";
            }
            
            @Override
            public Kind getKind() {
                return Kind.IDENT;
            }
        }
        public static IDENT IDENT(@NonNull String value) {
            return new IDENT(value);
        }
        
        public final static class ACTION extends Token {
            public final @NonNull Extent value;
            
            private ACTION(@NonNull Extent value) {
                this.value = value;
            }
            
            @Override
            public String toString() {
                return "ACTION(" + value + ")";
            }
            
            @Override
            public Kind getKind() {
                return Kind.ACTION;
            }
        }
        public static ACTION ACTION(@NonNull Extent value) {
            return new ACTION(value);
        }
        
        public final static class ARGUMENTS extends Token {
            public final @NonNull Extent value;
            
            private ARGUMENTS(@NonNull Extent value) {
                this.value = value;
            }
            
            @Override
            public String toString() {
                return "ARGUMENTS(" + value + ")";
            }
            
            @Override
            public Kind getKind() {
                return Kind.ARGUMENTS;
            }
        }
        public static ARGUMENTS ARGUMENTS(@NonNull Extent value) {
            return new ARGUMENTS(value);
        }
        
        public final static class STRING extends Token {
            public final @NonNull String value;
            
            private STRING(@NonNull String value) {
                this.value = value;
            }
            
            @Override
            public String toString() {
                return "STRING(" + value + ")";
            }
            
            @Override
            public Kind getKind() {
                return Kind.STRING;
            }
        }
        public static STRING STRING(@NonNull String value) {
            return new STRING(value);
        }
        
        private static abstract class Singleton extends Token {
            private final Kind kind;
            private Singleton(Kind kind) { this.kind = kind; }
            
            @Override
            public String toString() {
                return kind.toString();
            }
            
            @Override
            public Kind getKind() {
                return kind;
            }
        }
        
        public static final Token EQUAL = new Singleton(Kind.EQUAL) {};
        public static final Token LSQUARE = new Singleton(Kind.LSQUARE) {};
        public static final Token RSQUARE = new Singleton(Kind.RSQUARE) {};
        public static final Token BAR = new Singleton(Kind.BAR) {};
        public static final Token DOT = new Singleton(Kind.DOT) {};
        public static final Token STAR = new Singleton(Kind.STAR) {};
        public static final Token SEMICOL = new Singleton(Kind.SEMICOL) {};
        public static final Token IMPORT = new Singleton(Kind.IMPORT) {};
        public static final Token STATIC = new Singleton(Kind.STATIC) {};
        public static final Token PUBLIC = new Singleton(Kind.PUBLIC) {};
        public static final Token PRIVATE = new Singleton(Kind.PRIVATE) {};
        public static final Token TOKEN = new Singleton(Kind.TOKEN) {};
        public static final Token RULE = new Singleton(Kind.RULE) {};
        public static final Token EOF = new Singleton(Kind.EOF) {};
    }
    
    
       /**
     * Returns {@code true} if the given string contains a lower-case letter
     */
    private static boolean isLowerId(String name) {
        return name.chars().anyMatch(ch -> Character.isLowerCase(ch));
    }

    private Production.@NonNull Actual actual(@Nullable Located<@NonNull String> binding,
            @NonNull Located<@NonNull String> ident, @Nullable Extent args) {
        if (args != null && Character.isUpperCase(ident.val.charAt(0)))
            throw new ParsingException(ident.start, ident.length(),
                "Terminal " + ident.val + " does not expect arguments.");
        return new Production.Actual(binding, ident, args);
    }

    /**
     * @param t
     * @return the given value wrapped with the location of the last
     * 	consumed token
     */
    private <@NonNull T> @NonNull Located<T> withLoc(T t) {
	     return Located.of(t, _jl_lastTokenStart, _jl_lastTokenEnd);
    }

    @SuppressWarnings("null")
    public <T extends codegen.LexBuffer>JGEParser(T lexbuf, java.util.function.Function<T, Token> tokens) {
        super(lexbuf, tokens);
    }
    
    private Token eat(Token.Kind kind) {
        Token ctoken = eat();
        if (kind != ctoken.getKind())
            throw tokenError(ctoken, kind);
        return ctoken;
    }
    
    public @NonNull Grammar start() {
        
        // options = options(null)
        @NonNull List<@NonNull Option> options = options(null);
        // imports = imports(null)
        @NonNull List<@NonNull Located<@NonNull String>> imports = imports(null);
        // tdecls = tokens(null)
        @NonNull List<@NonNull TokenDecl> tdecls = tokens(null);
        // header = ACTION
        @NonNull Extent header = ((Token.ACTION) eat(Token.Kind.ACTION)).value;
        // rules = rules(null)
        @NonNull List<@NonNull GrammarRule> rules = rules(null);
        // footer = ACTION
        @NonNull Extent footer = ((Token.ACTION) eat(Token.Kind.ACTION)).value;
        // EOF
        eat(Token.Kind.EOF);
        Grammar.Builder builder = new Grammar.Builder(options, imports, header, footer);
        tdecls.forEach(tdecl -> builder.addToken(tdecl));
        rules.forEach(rule -> builder.addRule(rule));
        return builder.build();
    }
    
    private @NonNull List<@NonNull Option> options(@Nullable List<@NonNull Option> opts) {
        switch (peek().getKind()) {
            case ACTION:
            case IMPORT:
            case TOKEN: {
                 return opts == null ? Lists.empty() : opts; 
            }
            case LSQUARE: {
                // LSQUARE
                eat(Token.Kind.LSQUARE);
                 @NonNull List<@NonNull Option> acc = opts == null ? new ArrayList<>() : opts; 
                // key = IDENT
                @NonNull String key = ((Token.IDENT) eat(Token.Kind.IDENT)).value;
                 @NonNull Located<@NonNull String> lkey = withLoc(key); 
                // EQUAL
                eat(Token.Kind.EQUAL);
                // value = STRING
                @NonNull String value = ((Token.STRING) eat(Token.Kind.STRING)).value;
                 @NonNull Located<@NonNull String> lvalue = withLoc(value); 
                // RSQUARE
                eat(Token.Kind.RSQUARE);
                 acc.add(Option.of(lkey, lvalue)); 
                // options(acc)
                options(acc);
                 return acc; 
            }
            default: {
                throw tokenError(peek(), Token.Kind.ACTION, Token.Kind.IMPORT, Token.Kind.LSQUARE, Token.Kind.TOKEN);
            }
        }
    }
    
    private @NonNull List<@NonNull Located<@NonNull String>> imports(@Nullable List<@NonNull Located<@NonNull String>> imp) {
        switch (peek().getKind()) {
            case ACTION:
            case TOKEN: {
                return imp == null ? Lists.empty() : imp;
            }
            case IMPORT: {
                @NonNull List<@NonNull Located<@NonNull String>> acc = imp == null ? new ArrayList<>() : imp;
                // IMPORT
                eat(Token.Kind.IMPORT);
                codegen.LexBuffer.Position start = _jl_lastTokenStart;
                // elt = import_
                String elt = import_();
                // SEMICOL
                eat(Token.Kind.SEMICOL);
                acc.add(Located.of("import " + elt + ";", start, _jl_lastTokenEnd));
                // imports(acc)
                imports(acc);
                return acc;
            }
            default: {
                throw tokenError(peek(), Token.Kind.ACTION, Token.Kind.IMPORT, Token.Kind.TOKEN);
            }
        }
    }
    
    private String import_() {
        switch (peek().getKind()) {
            case IDENT: {
                // id = IDENT
                @NonNull String id = ((Token.IDENT) eat(Token.Kind.IDENT)).value;
                // tn = typename
                String tn = typename();
                return id + tn;
            }
            case STATIC: {
                // STATIC
                eat(Token.Kind.STATIC);
                // id = IDENT
                @NonNull String id = ((Token.IDENT) eat(Token.Kind.IDENT)).value;
                // tn = typename
                String tn = typename();
                return "static " + id + tn;
            }
            default: {
                throw tokenError(peek(), Token.Kind.IDENT, Token.Kind.STATIC);
            }
        }
    }
    
    private String typename() {
        switch (peek().getKind()) {
            case DOT: {
                // DOT
                eat(Token.Kind.DOT);
                // ty = typename0
                String ty = typename0();
                return "." + ty;
            }
            case SEMICOL: {
                return "";
            }
            default: {
                throw tokenError(peek(), Token.Kind.DOT, Token.Kind.SEMICOL);
            }
        }
    }
    
    private String typename0() {
        switch (peek().getKind()) {
            case IDENT: {
                // id = IDENT
                @NonNull String id = ((Token.IDENT) eat(Token.Kind.IDENT)).value;
                // ty = typename
                String ty = typename();
                return id + ty;
            }
            case STAR: {
                // STAR
                eat(Token.Kind.STAR);
                return "*";
            }
            default: {
                throw tokenError(peek(), Token.Kind.IDENT, Token.Kind.STAR);
            }
        }
    }
    
    private @NonNull List<@NonNull TokenDecl> tokens(@Nullable List<@NonNull TokenDecl> tokens) {
        switch (peek().getKind()) {
            case ACTION: {
                return Lists.empty();
            }
            case TOKEN: {
                @NonNull List<@NonNull TokenDecl> acc = tokens == null ? new ArrayList<>() : tokens;
                // TOKEN
                eat(Token.Kind.TOKEN);
                // tok = token_
                @NonNull TokenDecl tok = token_();
                acc.add(tok);
                // tokens(acc)
                tokens(acc);
                return acc;
            }
            default: {
                throw tokenError(peek(), Token.Kind.ACTION, Token.Kind.TOKEN);
            }
        }
    }
    
    private @NonNull TokenDecl token_() {
        switch (peek().getKind()) {
            case ACTION: {
                // val = ACTION
                @NonNull Extent val = ((Token.ACTION) eat(Token.Kind.ACTION)).value;
                // id = IDENT
                @NonNull String id = ((Token.IDENT) eat(Token.Kind.IDENT)).value;
                if (isLowerId(id))
                    throw parsingError("Token name should be all uppercase: " + id);
                return new TokenDecl(withLoc(id), val);
            }
            case IDENT: {
                // id = IDENT
                @NonNull String id = ((Token.IDENT) eat(Token.Kind.IDENT)).value;
                if (isLowerId(id))
                   throw parsingError("Token name should be all uppercase: " + id);
                return new TokenDecl(withLoc(id), null);
            }
            default: {
                throw tokenError(peek(), Token.Kind.ACTION, Token.Kind.IDENT);
            }
        }
    }
    
    private @NonNull List<@NonNull GrammarRule> rules(@Nullable List<@NonNull GrammarRule> rules) {
        switch (peek().getKind()) {
            case ACTION: {
                return Lists.empty();
            }
            case PRIVATE:
            case PUBLIC: {
                // r = rule_
                @NonNull GrammarRule r = rule_();
                @NonNull List<@NonNull GrammarRule> acc = rules == null ? new ArrayList<>() : rules;
                acc.add(r);
                // rules(acc)
                rules(acc);
                return acc;
            }
            default: {
                throw tokenError(peek(), Token.Kind.ACTION, Token.Kind.PRIVATE, Token.Kind.PUBLIC);
            }
        }
    }
    
    private @NonNull GrammarRule rule_() {
        
        // vis = visibility
        boolean vis = visibility();
        // rtype = ACTION
        @NonNull Extent rtype = ((Token.ACTION) eat(Token.Kind.ACTION)).value;
        // RULE
        eat(Token.Kind.RULE);
        // name = IDENT
        @NonNull String name = ((Token.IDENT) eat(Token.Kind.IDENT)).value;
        if (!Character.isLowerCase(name.charAt(0)))
            throw parsingError("Rule name must start with a lower case letter: " + name);
        @NonNull Located<@NonNull String> lname = withLoc(name);
        // args = args
        @Nullable Extent args = args();
        // EQUAL
        eat(Token.Kind.EQUAL);
        GrammarRule.@NonNull Builder builder =
        	new GrammarRule.Builder(vis, rtype, lname, args);
        // prod = production
        @NonNull Production prod = production();
        builder.addProduction(prod);
        // productions(builder)
        productions(builder);
        return builder.build();
    }
    
    private boolean visibility() {
        switch (peek().getKind()) {
            case PRIVATE: {
                // PRIVATE
                eat(Token.Kind.PRIVATE);
                return false;
            }
            case PUBLIC: {
                // PUBLIC
                eat(Token.Kind.PUBLIC);
                return true;
            }
            default: {
                throw tokenError(peek(), Token.Kind.PRIVATE, Token.Kind.PUBLIC);
            }
        }
    }
    
    private @Nullable Extent args() {
        switch (peek().getKind()) {
            case ACTION:
            case BAR:
            case EQUAL:
            case IDENT:
            case SEMICOL: {
                return null;
            }
            case ARGUMENTS: {
                // ext = ARGUMENTS
                @NonNull Extent ext = ((Token.ARGUMENTS) eat(Token.Kind.ARGUMENTS)).value;
                return ext;
            }
            default: {
                throw tokenError(peek(), Token.Kind.ACTION, Token.Kind.ARGUMENTS, Token.Kind.BAR, Token.Kind.EQUAL, Token.Kind.IDENT, Token.Kind.SEMICOL);
            }
        }
    }
    
    private void productions(GrammarRule.@NonNull Builder builder) {
        switch (peek().getKind()) {
            case BAR: {
                // prod = production
                @NonNull Production prod = production();
                builder.addProduction(prod);
                // productions(builder)
                productions(builder);
                return;
            }
            case SEMICOL: {
                // SEMICOL
                eat(Token.Kind.SEMICOL);
                return;
            }
            default: {
                throw tokenError(peek(), Token.Kind.BAR, Token.Kind.SEMICOL);
            }
        }
    }
    
    private @NonNull Production production() {
        
        // BAR
        eat(Token.Kind.BAR);
        Production.Builder builder = new Production.Builder();
        // items(builder)
        items(builder);
        return builder.build();
    }
    
    private void items(Production.Builder builder) {
        switch (peek().getKind()) {
            case ACTION: {
                // ext = ACTION
                @NonNull Extent ext = ((Token.ACTION) eat(Token.Kind.ACTION)).value;
                builder.addAction(ext);
                // items(builder)
                items(builder);
                return;
            }
            case BAR:
            case SEMICOL: {
                return;
            }
            case IDENT: {
                // id = IDENT
                @NonNull String id = ((Token.IDENT) eat(Token.Kind.IDENT)).value;
                // actual = actual(withLoc(id))
                Production.@NonNull Actual actual = actual(withLoc(id));
                builder.addActual(actual);
                // items(builder)
                items(builder);
                return;
            }
            default: {
                throw tokenError(peek(), Token.Kind.ACTION, Token.Kind.BAR, Token.Kind.IDENT, Token.Kind.SEMICOL);
            }
        }
    }
    
    private Production.@NonNull Actual actual(@NonNull Located<@NonNull String> id) {
        switch (peek().getKind()) {
            case ACTION:
            case ARGUMENTS:
            case BAR:
            case IDENT:
            case SEMICOL: {
                // args = args
                @Nullable Extent args = args();
                return actual(null, id, args);
            }
            case EQUAL: {
                // EQUAL
                eat(Token.Kind.EQUAL);
                // name = IDENT
                @NonNull String name = ((Token.IDENT) eat(Token.Kind.IDENT)).value;
                Located<@NonNull String> lname = withLoc(name);
                // args = args
                @Nullable Extent args = args();
                return actual(id, lname, args);
            }
            default: {
                throw tokenError(peek(), Token.Kind.ACTION, Token.Kind.ARGUMENTS, Token.Kind.BAR, Token.Kind.EQUAL, Token.Kind.IDENT, Token.Kind.SEMICOL);
            }
        }
    }
    
       /**
     * Testing this parser
     */
    public static void main(String[] args) throws java.io.IOException {
		String prompt;
       while ((prompt = common.Prompt.getInputLine(">")) != null) {
			try {
				JGELexer lexer = new JGELexer("-",
					new java.io.StringReader(prompt));
				JGEParser parser = new JGEParser(lexer, JGELexer::main);
				System.out.println(parser.start());
			} catch (ParsingException e) {
				e.printStackTrace();
			}
		}
	}

    
}
