// This grammar is for now equivalent to that of simple grammars,
// it has been produced by pretty-printing the declarative 
// grammar description built in jg.JGParser.

import org.eclipse.jdt.annotation.Nullable;
import org.eclipse.jdt.annotation.NonNull;
import java.util.List;
import java.util.ArrayList;
import common.Lists;
import common.Java;
import syntax.Extent;
import syntax.PExtent;
import syntax.Located;
import syntax.Production;
import syntax.Option;
import syntax.Grammar.TokenDecl;
import syntax.GrammarRule;
import syntax.Grammar;

token {String} IDENT
token {PExtent} ACTION
token {PExtent} ARGUMENTS
token {String} MLSTRING
token EQUAL
token LSQUARE 
token RSQUARE
token BAR
token DOT
token STAR
token SEMICOL
token IMPORT
token STATIC
token PUBLIC
token PRIVATE
token TOKEN
token RULE
token CONTINUE
token EOF

{   /**
     * Returns {@code true} if the given string contains a lower-case letter
     */
    private static boolean isLowerId(String name) {
        return name.chars().anyMatch(ch -> Character.isLowerCase(ch));
    }

    private Production.Actual actual(@Nullable Located<String> binding,
            Located<String> ident, @Nullable Extent args) {
        if (args != null && Character.isUpperCase(ident.val.charAt(0)))
            throw new ParsingException(ident.start, ident.length(),
                "Terminal " + ident.val + " does not expect arguments.");
        return new Production.Actual(binding, ident, args);
    }

    /**
     * @param t
     * @return the given value wrapped with the location of the last
     * 	consumed token
     */
    private <@NonNull T> Located<T> withLoc(T t) {
	     return Located.of(t, _jl_lastTokenStart, _jl_lastTokenEnd);
    }
    
    private String validJavaIdent(String id) {
    	if (Java.keywordSet.contains(id))
    		throw parsingError("Invalid name: reserved Java identifier");
    	return id;
    }
    
    private void invalidContinuation() {
    	throw parsingError("Continuation must appear last in a production rule");
    }
}

public {Grammar} rule start = 
|   options = options(null)
    imports = imports(null) 
	tdecls = tokens(null) 
	header = ACTION 
	rules = rules(null) 
	footer = ACTION EOF 
	{Grammar.Builder builder = new Grammar.Builder(options, imports, header, footer);} 
	{tdecls.forEach(tdecl -> builder.addToken(tdecl));} 
	{rules.forEach(rule -> builder.addRule(rule));} 
	{return builder.build();};

private {List<Option>} rule options(@Nullable List<Option> opts) =
| 	
	{ return opts == null ? Lists.empty() : opts; }
|   LSQUARE
	{ List<Option> acc = opts == null ? new ArrayList<>() : opts; }
	key = IDENT 
	{ Located<String> lkey = withLoc(key); }
	EQUAL value = MLSTRING	
	{ Located<String> lvalue = withLoc(value); }
	RSQUARE
	{ acc.add(Option.of(lkey, lvalue)); }
	options(acc)
	{ return acc; }
;

private {List<Located<String>>} rule imports(@Nullable List<Located<String>> imp) = 
|  {return imp == null ? Lists.empty() : imp;}
|  {List<Located<String>> acc = imp == null ? new ArrayList<>() : imp;} 
	IMPORT {codegen.LexBuffer.Position start = _jl_lastTokenStart;} 
	elt = import_ SEMICOL {acc.add(Located.of("import " + elt + ";", start, _jl_lastTokenEnd));} 
	imports(acc) {return acc;};

private {String} rule import_ = 
|  STATIC id = IDENT tn = typename {return "static " + id + tn;}
|  id = IDENT tn = typename {return id + tn;};

private {String} rule typename = 
|  {return "";}
|  DOT ty = typename0 {return "." + ty;};

private {String} rule typename0 = 
|  STAR {return "*";}
|  id = IDENT ty = typename {return id + ty;};

private { List<TokenDecl> } rule tokens(@Nullable List<TokenDecl> tokens) = 
|  { return Lists.empty(); }
|  { List<TokenDecl> acc = tokens == null ? new ArrayList<>() : tokens; } 
	TOKEN token_decls(acc) tokens(acc) 
   { return acc; }
;

private { void } rule token_decls(List<TokenDecl> tokens) =
// NB: all reserved Java keywords/literals are lowercase, so no clash with tokens
|  value = token_value() id = IDENT
	{ if (isLowerId(id)) throw parsingError("Token name should be all uppercase: " + id); }
    { tokens.add(new TokenDecl(withLoc(id), value)); }
   more_token_decls(tokens, value)
	{ return; }
;

private { @Nullable Extent } rule token_value() =
|	{ return null; }
|	val = ACTION
	{ return val; }
;

private { void } rule more_token_decls(List<TokenDecl> tokens, @Nullable Extent value) =
// NB: all reserved Java keywords/literals are lowercase, so no clash with tokens
|  id = IDENT
	{ if (isLowerId(id)) throw parsingError("Token name should be all uppercase: " + id); }
    { tokens.add(new TokenDecl(withLoc(id), value)); }
   more_token_decls(tokens, value)
    { return; }
|	{ return; }
;

private {List<GrammarRule>} rule rules(@Nullable List<GrammarRule> rules) = 
|  {return Lists.empty();}
|  r = rule_ { List<GrammarRule> acc = rules == null ? new ArrayList<>() : rules; } 
	{ acc.add(r); } rules(acc) {return acc;};

private {GrammarRule} rule rule_ = 
|  vis = visibility rtype = ACTION RULE name = IDENT 
	{ if (!Character.isLowerCase(name.charAt(0))) } 
	{    throw parsingError("Rule name must start with a lower case letter: " + name); } 
	{ Located<String> lname = withLoc(validJavaIdent(name)); } 
	args = args EQUAL 
	{ GrammarRule.Builder builder = new GrammarRule.Builder(vis, rtype, lname, args); } 
	prod = production 
	{ builder.addProduction(prod); } 
	productions(builder) 
	{ return builder.build(); }
;

private { boolean } rule visibility = 
|  PUBLIC { return true; }
|  PRIVATE { return false; }
;

private { @Nullable Extent } rule args = 
|  { return null; }
|  ext = ARGUMENTS { return ext; }
;

private {void} rule productions(GrammarRule.Builder builder) = 
|   SEMICOL { return; }
|   prod = production { builder.addProduction(prod); } 
	productions(builder) { return; }
;

private { Production } rule production = 
|   BAR  { Production.Builder builder = new Production.Builder(); } 
	items(builder) { return builder.build(); }
;

private { void } rule items(Production.Builder builder) = 
|	{ return ;}
|   ext = ACTION { builder.addAction(ext); } items(builder) { return; }
|   id = IDENT actual = actual(withLoc(id)) { builder.addActual(actual); } 
	items(builder) { return; }
|	CONTINUE 
	{ builder.addItem(new Production.Continue(withLoc("continue"))); }
	// A dummy rule to provide a specific error message
	forbid_more_items() 
	{ return; }
;

private { void } rule forbid_more_items() =
|	{ return; }
|	{ invalidContinuation(); } ACTION { return; /* dead code */ }
|	{ invalidContinuation(); } IDENT  { return; /* dead code */ }
;

private { Production.Actual } rule actual(Located<String> id) =
|  args = args { return actual(null, id, args); }
|  { validJavaIdent(id.val); }
	EQUAL name = IDENT { Located<String> lname = withLoc(name); }
	args = args { return actual(id, lname, args); }
;

{   /**
     * Testing this parser
     */
    public static void main(String[] args) throws java.io.IOException {
		String prompt;
       while ((prompt = common.Prompt.getInputLine(">")) != null) {
			try {
				JGELexer lexer = new JGELexer("-",
					new java.io.StringReader(prompt));
				JGEParser parser = new JGEParser(lexer, JGELexer::main);
				System.out.println(parser.start());
			} catch (ParsingException e) {
				e.printStackTrace();
			}
		}
	}
}