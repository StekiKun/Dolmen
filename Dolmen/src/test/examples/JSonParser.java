package test.examples;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import common.Lists;
import common.Maps;
/**
 * Parser generated by Dolmen 
 */
@SuppressWarnings("javadoc")
@org.eclipse.jdt.annotation.NonNullByDefault({})
public final class JSonParser extends codegen.BaseParser<JSonParser.Token> {
    
    public static abstract class Token {
        
        public enum Kind {
            LBRACKET,
            RBRACKET,
            COMMA,
            COLON,
            LSQUARE,
            RSQUARE,
            TRUE,
            FALSE,
            NULL,
            STRING,
            NUMBER,
            EOF;
        }
        
        private Token()  {
            // nothing to do
        }
        
        @Override
        public abstract String toString();
        
        public abstract Kind getKind();
        
        public final static class STRING extends Token {
            public final  String  value;
            
            private STRING( String  value) {
                this.value = value;
            }
            
            @Override
            public String toString() {
                return "STRING(" + value + ")";
            }
            
            @Override
            public Kind getKind() {
                return Kind.STRING;
            }
        }
        public static STRING STRING( String  value) {
            return new STRING(value);
        }
        
        public final static class NUMBER extends Token {
            public final  double  value;
            
            private NUMBER( double  value) {
                this.value = value;
            }
            
            @Override
            public String toString() {
                return "NUMBER(" + value + ")";
            }
            
            @Override
            public Kind getKind() {
                return Kind.NUMBER;
            }
        }
        public static NUMBER NUMBER( double  value) {
            return new NUMBER(value);
        }
        
        private static abstract class Singleton extends Token {
            private final Kind kind;
            private Singleton(Kind kind) { this.kind = kind; }
            
            @Override
            public String toString() {
                return kind.toString();
            }
            
            @Override
            public Kind getKind() {
                return kind;
            }
        }
        
        public static final Token LBRACKET = new Singleton(Kind.LBRACKET) {};
        public static final Token RBRACKET = new Singleton(Kind.RBRACKET) {};
        public static final Token COMMA = new Singleton(Kind.COMMA) {};
        public static final Token COLON = new Singleton(Kind.COLON) {};
        public static final Token LSQUARE = new Singleton(Kind.LSQUARE) {};
        public static final Token RSQUARE = new Singleton(Kind.RSQUARE) {};
        public static final Token TRUE = new Singleton(Kind.TRUE) {};
        public static final Token FALSE = new Singleton(Kind.FALSE) {};
        public static final Token NULL = new Singleton(Kind.NULL) {};
        public static final Token EOF = new Singleton(Kind.EOF) {};
    }
    
    
    
	public enum ValueKind {
		STRING, NUMBER, OBJECT, ARRAY,
		TRUE, FALSE, NULL;
	}

	public static abstract class Value<T> {
		public final T val;
		private Value(T val) { this.val = val; }
		
		@Override public abstract String toString();
		public abstract ValueKind getKind();
	}

	public static final class ValueString extends Value<String> {
		private ValueString(String val) {
			super(val);
		}
		
		@Override public String toString() {
			return val;
		}
		
		@Override public ValueKind getKind() {
			return ValueKind.STRING;
		}
	}
	public static ValueString valString(String s) {
		return new ValueString(s);
	}

	public static final class ValueNumber extends Value<Double> {
		private ValueNumber(double val) {
			super(val);
		}
		
		@Override public String toString() {
			return "" + val;
		}
		
		@Override public ValueKind getKind() {
			return ValueKind.NUMBER;
		}
	}
	public static ValueNumber valNumber(double val) {
		return new ValueNumber(val);
	}
	
	public static final class ValueObject extends Value<Map<String, Value<?>>> {
		private ValueObject(Map<String, Value<?>> val) {
			super(val);
		}
		
		@Override public String toString() {
			return "" + val;	// TODO better pprint
		}
		
		@Override public ValueKind getKind() {
			return ValueKind.OBJECT;
		}
	}
	public static ValueObject valObject(Map<String, Value<?>> obj) {
		return new ValueObject(obj);
	}
	
	public static final class ValueArray extends Value<List<Value<?>>> {
		private ValueArray(List<Value<?>> val) {
			super(val);
		}
		
		@Override public String toString() {
			return "" + val;
		}
	
		@Override public ValueKind getKind() {
			return ValueKind.ARRAY;
		}
	}
	public static ValueArray valArray(List<Value<?>> arr) {
		return new ValueArray(arr);
	}
	
	public static final class ValueTrue extends Value<Boolean> {
		private ValueTrue() {
			super(true);
		}
		
		@Override public String toString() {
			return "true";
		}
		
		@Override public ValueKind getKind() {
			return ValueKind.TRUE;
		}	
	}
	public static final ValueTrue valTrue = new ValueTrue();
	
	public static final class ValueFalse extends Value<Boolean> {
		private ValueFalse() {
			super(false);
		}
		
		@Override public String toString() {
			return "false";
		}
		
		@Override public ValueKind getKind() {
			return ValueKind.FALSE;
		}	
	}
	public static final ValueFalse valFalse = new ValueFalse();
	
	public static final class ValueNull extends Value<Object> {
		private ValueNull() {
			super(null);
		}
		
		@Override public String toString() {
			return "null";
		}
		
		@Override public ValueKind getKind() {
			return ValueKind.NULL;
		}	
	}
	public static final ValueNull valNull = new ValueNull();

    @SuppressWarnings("null")
    public JSonParser(java.util.function.Supplier<Token> tokens) {
        super(tokens);
    }
    
    private Token eat(Token.Kind kind) {
        Token ctoken = peek();
        if (kind != ctoken.getKind())
        throw tokenError(ctoken, kind);
        _jl_nextToken = null;
        return ctoken;
    }
    
    public  Value<?>  json() {
        
        // v = value
         Value<?>  v = value();
        // EOF
        eat(Token.Kind.EOF);
         return v; 
    }
    
    private  Value<?>  value() {
        switch (peek().getKind()) {
            case NUMBER: {
                // n = NUMBER
                 double  n = ((Token.NUMBER) eat(Token.Kind.NUMBER)).value;
                 return valNumber(n); 
            }
            case NULL: {
                // NULL
                eat(Token.Kind.NULL);
                 return valNull; 
            }
            case LSQUARE: {
                // a = array
                 List<Value<?>>  a = array();
                 return valArray(a); 
            }
            case LBRACKET: {
                // o = object
                 Map<String, Value<?>>  o = object();
                 return valObject(o); 
            }
            case STRING: {
                // s = STRING
                 String  s = ((Token.STRING) eat(Token.Kind.STRING)).value;
                 return valString(s); 
            }
            case FALSE: {
                // FALSE
                eat(Token.Kind.FALSE);
                 return valFalse; 
            }
            case TRUE: {
                // TRUE
                eat(Token.Kind.TRUE);
                 return valTrue; 
            }
            default: {
                throw tokenError(peek(), Token.Kind.LSQUARE, Token.Kind.NUMBER, Token.Kind.NULL, Token.Kind.STRING, Token.Kind.LBRACKET, Token.Kind.TRUE, Token.Kind.FALSE);
            }
        }
    }
    
    private  List<Value<?>>  array() {
        
        // LSQUARE
        eat(Token.Kind.LSQUARE);
        // elts = elements(null)
         List<Value<?>>  elts = elements(null);
         return elts; 
    }
    
    private  List<Value<?>>  elements(List<Value<?>> elts) {
        switch (peek().getKind()) {
            case RSQUARE: {
                // RSQUARE
                eat(Token.Kind.RSQUARE);
                 return elts == null ? Lists.empty() : elts; 
            }
            case LSQUARE:
            case NUMBER:
            case NULL:
            case STRING:
            case LBRACKET:
            case TRUE:
            case FALSE: {
                // val = value
                 Value<?>  val = value();
                 List<Value<?>> acc = elts == null ? new ArrayList<>() : elts; 
                 acc.add(val); 
                // more_elements(acc)
                more_elements(acc);
                 return acc; 
            }
            default: {
                throw tokenError(peek(), Token.Kind.RSQUARE, Token.Kind.LSQUARE, Token.Kind.NUMBER, Token.Kind.NULL, Token.Kind.STRING, Token.Kind.LBRACKET, Token.Kind.TRUE, Token.Kind.FALSE);
            }
        }
    }
    
    private  void  more_elements(List<Value<?>> elts) {
        switch (peek().getKind()) {
            case COMMA: {
                // COMMA
                eat(Token.Kind.COMMA);
                // val = value
                 Value<?>  val = value();
                 elts.add(val); 
                // more_elements(elts)
                more_elements(elts);
                 return; 
            }
            case RSQUARE: {
                // RSQUARE
                eat(Token.Kind.RSQUARE);
                 return; 
            }
            default: {
                throw tokenError(peek(), Token.Kind.COMMA, Token.Kind.RSQUARE);
            }
        }
    }
    
    private  Map<String, Value<?>>  object() {
        
        // LBRACKET
        eat(Token.Kind.LBRACKET);
        // members = members(null)
         Map<String, Value<?>>  members = members(null);
         return members; 
    }
    
    private  Map<String, Value<?>>  members(Map<String, Value<?>> members) {
        switch (peek().getKind()) {
            case STRING: {
                 Map<String, Value<?>> acc = members == null ? new HashMap<>() : members; 
                // pair(acc)
                pair(acc);
                // more_members(acc)
                more_members(acc);
                 return acc; 
            }
            case RBRACKET: {
                // RBRACKET
                eat(Token.Kind.RBRACKET);
                 return members == null ? Maps.empty() : members; 
            }
            default: {
                throw tokenError(peek(), Token.Kind.STRING, Token.Kind.RBRACKET);
            }
        }
    }
    
    private  void  more_members(Map<String, Value<?>> members) {
        switch (peek().getKind()) {
            case RBRACKET: {
                // RBRACKET
                eat(Token.Kind.RBRACKET);
                 return; 
            }
            case COMMA: {
                // COMMA
                eat(Token.Kind.COMMA);
                // pair(members)
                pair(members);
                // more_members(members)
                more_members(members);
                 return; 
            }
            default: {
                throw tokenError(peek(), Token.Kind.COMMA, Token.Kind.RBRACKET);
            }
        }
    }
    
    private  void  pair(Map<String, Value<?>> map) {
        
        // s = STRING
         String  s = ((Token.STRING) eat(Token.Kind.STRING)).value;
        // COLON
        eat(Token.Kind.COLON);
        // val = value
         Value<?>  val = value();
         map.put(s, val); return; 
    }
    
     
    
}
