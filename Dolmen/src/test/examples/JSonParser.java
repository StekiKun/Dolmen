package test.examples;
import org.eclipse.jdt.annotation.Nullable;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import common.Lists;
import common.Maps;

/**
 * Parser generated by Dolmen 1.0.0
 */
public final class JSonParser extends codegen.BaseParser.WithPositions<JSonParser.Token> {
    
    @SuppressWarnings("javadoc")
    public static abstract class Token {
        
        public enum Kind {
            LBRACKET,
            RBRACKET,
            COMMA,
            COLON,
            LSQUARE,
            RSQUARE,
            TRUE,
            FALSE,
            NULL,
            STRING,
            NUMBER,
            EOF;
        }
        
        private Token(Kind kind)  {
            this.kind = kind;
        }
        private final Kind kind;
        
        @Override
        public abstract String toString();
        
        public final Kind getKind() { return kind; }
        
        public final static class STRING extends Token {
            public final  String  value;
            
            private STRING( String  value) {
                super(Kind.STRING);
                this.value = value;
            }
            
            @Override
            public String toString() {
                return "STRING(" + value + ")";
            }
        }
        public static STRING STRING( String  value) {
            return new STRING(value);
        }
        
        public final static class NUMBER extends Token {
            public final  double  value;
            
            private NUMBER( double  value) {
                super(Kind.NUMBER);
                this.value = value;
            }
            
            @Override
            public String toString() {
                return "NUMBER(" + value + ")";
            }
        }
        public static NUMBER NUMBER( double  value) {
            return new NUMBER(value);
        }
        
        private static final class Singleton extends Token {
            private Singleton(Kind kind) { super(kind); }
            
            @Override
            public String toString() {
                return getKind().toString();
            }
        }
        
        public static final Token LBRACKET = new Singleton(Kind.LBRACKET);
        public static final Token RBRACKET = new Singleton(Kind.RBRACKET);
        public static final Token COMMA = new Singleton(Kind.COMMA);
        public static final Token COLON = new Singleton(Kind.COLON);
        public static final Token LSQUARE = new Singleton(Kind.LSQUARE);
        public static final Token RSQUARE = new Singleton(Kind.RSQUARE);
        public static final Token TRUE = new Singleton(Kind.TRUE);
        public static final Token FALSE = new Singleton(Kind.FALSE);
        public static final Token NULL = new Singleton(Kind.NULL);
        public static final Token EOF = new Singleton(Kind.EOF);
    }
    
    
    
	@SuppressWarnings("javadoc")
	public enum ValueKind {
		STRING, NUMBER, OBJECT, ARRAY,
		TRUE, FALSE, NULL;
	}

	@SuppressWarnings("javadoc")
	public static abstract class Value<T> {
		public final T val;
		private Value(T val) { this.val = val; }
		
		@Override public abstract String toString();
		public abstract ValueKind getKind();
	}

	@SuppressWarnings("javadoc")
	public static final class ValueString extends Value<String> {
		private ValueString(String val) {
			super(val);
		}
		
		@Override public String toString() {
			return val;
		}
		
		@Override public ValueKind getKind() {
			return ValueKind.STRING;
		}
	}
	@SuppressWarnings("javadoc")
	public static ValueString valString(String s) {
		return new ValueString(s);
	}
	
	@SuppressWarnings("javadoc")
	public static final class ValueNumber extends Value<Double> {
		private ValueNumber(double val) {
			super(val);
		}
		
		@Override public String toString() {
			return "" + val;
		}
		
		@Override public ValueKind getKind() {
			return ValueKind.NUMBER;
		}
	}
	@SuppressWarnings("javadoc")
	public static ValueNumber valNumber(double val) {
		return new ValueNumber(val);
	}

	@SuppressWarnings("javadoc")
	public static final class ValueObject extends Value<Map<String, Value<?>>> {
		private ValueObject(Map<String, Value<?>> val) {
			super(val);
		}
		
		@Override public String toString() {
			return "" + val;	// TODO better pprint
		}
		
		@Override public ValueKind getKind() {
			return ValueKind.OBJECT;
		}
	}
	@SuppressWarnings("javadoc")
	public static ValueObject valObject(Map<String, Value<?>> obj) {
		return new ValueObject(obj);
	}
	
	@SuppressWarnings("javadoc")
	public static final class ValueArray extends Value<List<Value<?>>> {
		private ValueArray(List<Value<?>> val) {
			super(val);
		}
		
		@Override public String toString() {
			return "" + val;
		}
	
		@Override public ValueKind getKind() {
			return ValueKind.ARRAY;
		}
	}
	@SuppressWarnings("javadoc")
	public static ValueArray valArray(List<Value<?>> arr) {
		return new ValueArray(arr);
	}
	
	@SuppressWarnings("javadoc")
	public static final class ValueTrue extends Value<Boolean> {
		private ValueTrue() {
			super(true);
		}
		
		@Override public String toString() {
			return "true";
		}
		
		@Override public ValueKind getKind() {
			return ValueKind.TRUE;
		}	
	}
	@SuppressWarnings("javadoc")
	public static final ValueTrue valTrue = new ValueTrue();
	
	@SuppressWarnings("javadoc")
	public static final class ValueFalse extends Value<Boolean> {
		private ValueFalse() {
			super(false);
		}
		
		@Override public String toString() {
			return "false";
		}
		
		@Override public ValueKind getKind() {
			return ValueKind.FALSE;
		}	
	}
	@SuppressWarnings("javadoc")
	public static final ValueFalse valFalse = new ValueFalse();
	
	@SuppressWarnings("javadoc")
	public static final class ValueNull extends Value<@Nullable Object> {
		private ValueNull() {
			super(null);
		}
		
		@Override public String toString() {
			return "null";
		}
		
		@Override public ValueKind getKind() {
			return ValueKind.NULL;
		}	
	}
	@SuppressWarnings("javadoc")
	public static final ValueNull valNull = new ValueNull();

    /**
     * Builds a new parser based on the given lexical buffer
     * and tokenizer
     * @param lexbuf
     * @param tokens
     */
    public <T extends codegen.LexBuffer> 
        JSonParser(T lexbuf, java.util.function.Function<T, Token> tokens) {
        super(lexbuf, tokens);
    }
    
    private Token eat(Token.Kind kind) {
        Token ctoken = eat();
        if (kind != ctoken.getKind())
            throw tokenError(ctoken, kind);
        return ctoken;
    }
    
    /**
     * Entry point for the non-terminal json
     */
    public  Value<?>  json() {
        enter(2);
        // v = value
         Value<?>  v = value();
        leave("v");
        // EOF
        eat(Token.Kind.EOF);
        shift(null);
         return v; 
    }
    
    private  Value<?>  value() {
        switch (peek().getKind()) {
            case FALSE: {
                enter(1);
                // FALSE
                eat(Token.Kind.FALSE);
                shift(null);
                 return valFalse; 
            }
            case LBRACKET: {
                enter(1);
                // o = object
                 Map<String, Value<?>>  o = object();
                leave("o");
                 return valObject(o); 
            }
            case LSQUARE: {
                enter(1);
                // a = array
                 List<Value<?>>  a = array();
                leave("a");
                 return valArray(a); 
            }
            case NULL: {
                enter(1);
                // NULL
                eat(Token.Kind.NULL);
                shift(null);
                 return valNull; 
            }
            case NUMBER: {
                enter(1);
                // n = NUMBER
                 double  n = ((Token.NUMBER) eat(Token.Kind.NUMBER)).value;
                shift("n");
                 return valNumber(n); 
            }
            case STRING: {
                enter(1);
                // s = STRING
                 String  s = ((Token.STRING) eat(Token.Kind.STRING)).value;
                shift("s");
                 return valString(s); 
            }
            case TRUE: {
                enter(1);
                // TRUE
                eat(Token.Kind.TRUE);
                shift(null);
                 return valTrue; 
            }
            default: {
                throw tokenError(peek(), Token.Kind.FALSE, Token.Kind.LBRACKET, Token.Kind.LSQUARE, Token.Kind.NULL, Token.Kind.NUMBER, Token.Kind.STRING, Token.Kind.TRUE);
            }
        }
    }
    
    private  List<Value<?>>  array() {
        enter(2);
        // LSQUARE
        eat(Token.Kind.LSQUARE);
        shift(null);
        // elts = elements(null)
         List<Value<?>>  elts = elements(null);
        leave("elts");
         return elts; 
    }
    
    private  List<Value<?>>  elements(@Nullable List<Value<?>> elts) {
        switch (peek().getKind()) {
            case FALSE:
            case LBRACKET:
            case LSQUARE:
            case NULL:
            case NUMBER:
            case STRING:
            case TRUE: {
                enter(2);
                // val = value
                 Value<?>  val = value();
                leave("val");
                 List<Value<?>> acc = elts == null ? new ArrayList<>() : elts; 
                 acc.add(val); 
                // more_elements(acc)
                more_elements(acc);
                leave(null);
                 return acc; 
            }
            case RSQUARE: {
                enter(1);
                // RSQUARE
                eat(Token.Kind.RSQUARE);
                shift(null);
                 return elts == null ? Lists.empty() : elts; 
            }
            default: {
                throw tokenError(peek(), Token.Kind.FALSE, Token.Kind.LBRACKET, Token.Kind.LSQUARE, Token.Kind.NULL, Token.Kind.NUMBER, Token.Kind.RSQUARE, Token.Kind.STRING, Token.Kind.TRUE);
            }
        }
    }
    
    private  void  more_elements(List<Value<?>> elts) {
        enter(2);
        more_elements:
        while (true) {
            switch (peek().getKind()) {
                case COMMA: {
                    // COMMA
                    eat(Token.Kind.COMMA);
                    shift(null);
                    // val = value
                     Value<?>  val = value();
                    leave("val");
                     elts.add(val); 
                    rewind();
                    continue more_elements;
                }
                case RSQUARE: {
                    // RSQUARE
                    eat(Token.Kind.RSQUARE);
                    shift(null);
                     return; 
                }
                default: {
                    throw tokenError(peek(), Token.Kind.COMMA, Token.Kind.RSQUARE);
                }
            }
        }
    }
    
    private  Map<String, Value<?>>  object() {
        enter(2);
        // LBRACKET
        eat(Token.Kind.LBRACKET);
        shift(null);
        // members = members(null)
         Map<String, Value<?>>  members = members(null);
        leave("members");
         return members; 
    }
    
    private  Map<String, Value<?>>  members(@Nullable Map<String, Value<?>> members) {
        switch (peek().getKind()) {
            case RBRACKET: {
                enter(1);
                // RBRACKET
                eat(Token.Kind.RBRACKET);
                shift(null);
                 return members == null ? Maps.empty() : members; 
            }
            case STRING: {
                enter(2);
                 Map<String, Value<?>> acc = members == null ? new HashMap<>() : members; 
                // pair(acc)
                pair(acc);
                leave(null);
                // more_members(acc)
                more_members(acc);
                leave(null);
                 return acc; 
            }
            default: {
                throw tokenError(peek(), Token.Kind.RBRACKET, Token.Kind.STRING);
            }
        }
    }
    
    private  void  more_members(Map<String, Value<?>> members) {
        enter(2);
        more_members:
        while (true) {
            switch (peek().getKind()) {
                case COMMA: {
                    // COMMA
                    eat(Token.Kind.COMMA);
                    shift(null);
                    // pair(members)
                    pair(members);
                    leave(null);
                    rewind();
                    continue more_members;
                }
                case RBRACKET: {
                    // RBRACKET
                    eat(Token.Kind.RBRACKET);
                    shift(null);
                     return; 
                }
                default: {
                    throw tokenError(peek(), Token.Kind.COMMA, Token.Kind.RBRACKET);
                }
            }
        }
    }
    
    private  void  pair(Map<String, Value<?>> map) {
        enter(3);
        // s = STRING
         String  s = ((Token.STRING) eat(Token.Kind.STRING)).value;
        shift("s");
        // COLON
        eat(Token.Kind.COLON);
        shift(null);
        // val = value
         Value<?>  val = value();
        leave("val");
         map.put(s, val); return; 
    }
    
     
    
}
