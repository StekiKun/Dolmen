package test.examples;
/**
 * Parser generated by Dolmen 
 */
@SuppressWarnings("javadoc")
@org.eclipse.jdt.annotation.NonNullByDefault({})
public final class StraightLineParser extends codegen.BaseParser<StraightLineParser.Token> {
    
    public static abstract class Token {
        
        public enum Kind {
            INT,
            ID,
            PLUS,
            MINUS,
            TIMES,
            DIV,
            SEMICOLON,
            ASSIGN,
            PRINT,
            LPAREN,
            RPAREN,
            COMMA,
            EOF;
        }
        
        private Token()  {
            // nothing to do
        }
        
        @Override
        public abstract String toString();
        
        public abstract Kind getKind();
        
        public final static class INT extends Token {
            public final int value;
            
            private INT(int value) {
                this.value = value;
            }
            
            @Override
            public String toString() {
                return "INT(" + value + ")";
            }
            
            @Override
            public Kind getKind() {
                return Kind.INT;
            }
        }
        public static INT INT(int value) {
            return new INT(value);
        }
        
        public final static class ID extends Token {
            public final String value;
            
            private ID(String value) {
                this.value = value;
            }
            
            @Override
            public String toString() {
                return "ID(" + value + ")";
            }
            
            @Override
            public Kind getKind() {
                return Kind.ID;
            }
        }
        public static ID ID(String value) {
            return new ID(value);
        }
        
        private static abstract class Singleton extends Token {
            private final Kind kind;
            private Singleton(Kind kind) { this.kind = kind; }
            
            @Override
            public String toString() {
                return kind.toString();
            }
            
            @Override
            public Kind getKind() {
                return kind;
            }
        }
        
        public static Token PLUS = new Singleton(Kind.PLUS) {};
        public static Token MINUS = new Singleton(Kind.MINUS) {};
        public static Token TIMES = new Singleton(Kind.TIMES) {};
        public static Token DIV = new Singleton(Kind.DIV) {};
        public static Token SEMICOLON = new Singleton(Kind.SEMICOLON) {};
        public static Token ASSIGN = new Singleton(Kind.ASSIGN) {};
        public static Token PRINT = new Singleton(Kind.PRINT) {};
        public static Token LPAREN = new Singleton(Kind.LPAREN) {};
        public static Token RPAREN = new Singleton(Kind.RPAREN) {};
        public static Token COMMA = new Singleton(Kind.COMMA) {};
        public static Token EOF = new Singleton(Kind.EOF) {};
    }
    
    
        private java.util.Map<String, Integer> env =
        new java.util.HashMap<>();
    
    private void update(String id, int n) {
        env.put(id, n);
    }
    
    private int lookup(String id) {
        if (!env.containsKey(id))
            throw new ParsingException("Undefined identifier: " + id);
        return env.get(id);
    }


    @SuppressWarnings("null")
    public StraightLineParser(java.util.function.Supplier<Token> tokens) {
        super(tokens);
    }
    
    private Token eat(Token.Kind kind) {
        Token ctoken = peek();
        if (kind != ctoken.getKind())
        throw tokenError(ctoken, kind);
        _jl_nextToken = null;
        return ctoken;
    }
    
    public void program() {
        switch (peek().getKind()) {
            case PRINT: {
                // stmts
                stmts();
                // EOF
                eat(Token.Kind.EOF);
                return;
            }
            case ID: {
                // stmts
                stmts();
                // EOF
                eat(Token.Kind.EOF);
                return;
            }
            default: {
                throw tokenError(peek(), Token.Kind.PRINT, Token.Kind.ID);
            }
        }
    }
    
    private void stmts() {
        switch (peek().getKind()) {
            case PRINT: {
                // stmt
                stmt();
                // stmts_rhs
                stmts_rhs();
                return;
            }
            case ID: {
                // stmt
                stmt();
                // stmts_rhs
                stmts_rhs();
                return;
            }
            default: {
                throw tokenError(peek(), Token.Kind.PRINT, Token.Kind.ID);
            }
        }
    }
    
    private void stmts_rhs() {
        switch (peek().getKind()) {
            case SEMICOLON: {
                // SEMICOLON
                eat(Token.Kind.SEMICOLON);
                // stmts
                stmts();
                return;
            }
            case EOF: {
                return;
            }
            default: {
                throw tokenError(peek(), Token.Kind.SEMICOLON, Token.Kind.EOF);
            }
        }
    }
    
    private void stmt() {
        switch (peek().getKind()) {
            case PRINT: {
                // PRINT
                eat(Token.Kind.PRINT);
                // LPAREN
                eat(Token.Kind.LPAREN);
                // pexpr
                pexpr();
                // pexprs
                pexprs();
                // RPAREN
                eat(Token.Kind.RPAREN);
                return;
            }
            case ID: {
                // id = ID
                String id = ((Token.ID) eat(Token.Kind.ID)).value;
                // ASSIGN
                eat(Token.Kind.ASSIGN);
                // n = expr
                int n = expr();
                update(id, n); return;
            }
            default: {
                throw tokenError(peek(), Token.Kind.PRINT, Token.Kind.ID);
            }
        }
    }
    
    private void pexprs() {
        switch (peek().getKind()) {
            case COMMA: {
                // COMMA
                eat(Token.Kind.COMMA);
                // pexpr
                pexpr();
                // pexprs
                pexprs();
                return;
            }
            case RPAREN: {
                return;
            }
            default: {
                throw tokenError(peek(), Token.Kind.COMMA, Token.Kind.RPAREN);
            }
        }
    }
    
    private void pexpr() {
        switch (peek().getKind()) {
            case LPAREN: {
                // e = expr
                int e = expr();
                System.out.println(e); return;
            }
            case ID: {
                // e = expr
                int e = expr();
                System.out.println(e); return;
            }
            case INT: {
                // e = expr
                int e = expr();
                System.out.println(e); return;
            }
            default: {
                throw tokenError(peek(), Token.Kind.LPAREN, Token.Kind.ID, Token.Kind.INT);
            }
        }
    }
    
    private int expr() {
        switch (peek().getKind()) {
            case LPAREN: {
                // n = term
                int n = term();
                return n;
            }
            case ID: {
                // n = term
                int n = term();
                return n;
            }
            case INT: {
                // n = term
                int n = term();
                return n;
            }
            default: {
                throw tokenError(peek(), Token.Kind.LPAREN, Token.Kind.ID, Token.Kind.INT);
            }
        }
    }
    
    private int term() {
        switch (peek().getKind()) {
            case LPAREN: {
                // n1 = factor
                int n1 = factor();
                // res = term_rhs(n1)
                int res = term_rhs(n1);
                return res;
            }
            case ID: {
                // n1 = factor
                int n1 = factor();
                // res = term_rhs(n1)
                int res = term_rhs(n1);
                return res;
            }
            case INT: {
                // n1 = factor
                int n1 = factor();
                // res = term_rhs(n1)
                int res = term_rhs(n1);
                return res;
            }
            default: {
                throw tokenError(peek(), Token.Kind.LPAREN, Token.Kind.ID, Token.Kind.INT);
            }
        }
    }
    
    private int term_rhs(int lhs) {
        switch (peek().getKind()) {
            case COMMA: {
                return lhs;
            }
            case SEMICOLON: {
                return lhs;
            }
            case RPAREN: {
                return lhs;
            }
            case EOF: {
                return lhs;
            }
            case PLUS: {
                // PLUS
                eat(Token.Kind.PLUS);
                // n = term
                int n = term();
                return lhs + n;
            }
            case MINUS: {
                // MINUS
                eat(Token.Kind.MINUS);
                // n = term
                int n = term();
                return lhs - n;
            }
            default: {
                throw tokenError(peek(), Token.Kind.COMMA, Token.Kind.SEMICOLON, Token.Kind.RPAREN, Token.Kind.EOF, Token.Kind.PLUS, Token.Kind.MINUS);
            }
        }
    }
    
    private int factor() {
        switch (peek().getKind()) {
            case LPAREN: {
                // n1 = atomic
                int n1 = atomic();
                // res = factor_rhs(n1)
                int res = factor_rhs(n1);
                return res;
            }
            case ID: {
                // n1 = atomic
                int n1 = atomic();
                // res = factor_rhs(n1)
                int res = factor_rhs(n1);
                return res;
            }
            case INT: {
                // n1 = atomic
                int n1 = atomic();
                // res = factor_rhs(n1)
                int res = factor_rhs(n1);
                return res;
            }
            default: {
                throw tokenError(peek(), Token.Kind.LPAREN, Token.Kind.ID, Token.Kind.INT);
            }
        }
    }
    
    private int factor_rhs(int lhs) {
        switch (peek().getKind()) {
            case DIV: {
                // DIV
                eat(Token.Kind.DIV);
                // n = factor
                int n = factor();
                return lhs / n;
            }
            case COMMA: {
                return lhs;
            }
            case TIMES: {
                // TIMES
                eat(Token.Kind.TIMES);
                // n = factor
                int n = factor();
                return lhs * n;
            }
            case SEMICOLON: {
                return lhs;
            }
            case RPAREN: {
                return lhs;
            }
            case EOF: {
                return lhs;
            }
            case PLUS: {
                return lhs;
            }
            case MINUS: {
                return lhs;
            }
            default: {
                throw tokenError(peek(), Token.Kind.DIV, Token.Kind.COMMA, Token.Kind.TIMES, Token.Kind.SEMICOLON, Token.Kind.RPAREN, Token.Kind.EOF, Token.Kind.PLUS, Token.Kind.MINUS);
            }
        }
    }
    
    private int atomic() {
        switch (peek().getKind()) {
            case LPAREN: {
                // LPAREN
                eat(Token.Kind.LPAREN);
                // e = expr
                int e = expr();
                // RPAREN
                eat(Token.Kind.RPAREN);
                return e;
            }
            case ID: {
                // id = ID
                String id = ((Token.ID) eat(Token.Kind.ID)).value;
                return lookup(id);
            }
            case INT: {
                // n = INT
                int n = ((Token.INT) eat(Token.Kind.INT)).value;
                return n;
            }
            default: {
                throw tokenError(peek(), Token.Kind.LPAREN, Token.Kind.ID, Token.Kind.INT);
            }
        }
    }
    
    /**
     * Testing this parser
     */
    public static void main(String[] args) throws java.io.IOException {
		String prompt;
       while ((prompt = common.Prompt.getInputLine(">")) != null) {
			try {
				StraightLineLexer lexer = new StraightLineLexer("-",
					new java.io.StringReader(prompt));
				StraightLineParser parser = new StraightLineParser(lexer::main);
				parser.program();
			} catch (ParsingException e) {
				e.printStackTrace();
			}
		}
	}

    
}
