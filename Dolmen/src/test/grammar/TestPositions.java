package test.grammar;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.util.Map;

import org.eclipse.jdt.annotation.Nullable;

import codegen.BaseParser.ParsingException;
import codegen.CodeBuilder;
import test.examples.JSonPosLexer;
import test.examples.JSonPosParser;
import test.examples.JSonPosParser.Located;
import test.examples.JSonPosParser.Value;
import test.examples.JSonPosParser.ValueArray;
import test.examples.JSonPosParser.ValueNumber;
import test.examples.JSonPosParser.ValueObject;
import test.examples.JSonPosParser.ValueString;

/**
 * This class tests the lexer/parser generated by Dolmen
 * from the {@code tests/jl/JSonPos.jl} and {@code tests/jg/JSonPos.jg}
 * files and the terminal and non-terminal positions stored in
 * the resulting values.
 * 
 * @author St√©phane Lescuyer
 */
public final class TestPositions {

	private TestPositions() {
		// Static utility only
	}
	
	private static class PrettyPrinter {
		private final CodeBuilder buf = new CodeBuilder(0);
		
		private void append(Value<?> val) {
			String loc = Value.locToString(val.start, val.end);
			switch (val.getKind()) {
			case ARRAY:
				buf.emit("Array ").emit(loc).newline();
				ValueArray arr = (ValueArray) val;
				if (arr.val.isEmpty())
					buf.emit("[]");
				else {
					buf.emit("[").incrIndent();
					for (Value<?> v : arr.val) {
						buf.newline(); 
						append(v);
					}
					buf.decrIndent().newline().emit("]");
				}
				break;
			case OBJECT:
				buf.emit("Object ").emit(loc).newline();
				ValueObject obj = (ValueObject) val;
				if (obj.val.isEmpty())
					buf.emit("[]");
				else {
					buf.emit("[").incrIndent();
					for (Map.Entry<Located<String>, Value<?>> entry : obj.val.entrySet()) {
						buf.newline();
						appendObjectEntry(entry.getKey(), entry.getValue());
					}
					buf.decrIndent().newline().emit("]");
				}
				break;
			case NUMBER:
				buf.emit("Number " + ((ValueNumber) val).val);
				buf.emit(" ").emit(loc);
				break;
			case STRING:
				buf.emit("String " + ((ValueString) val).val);
				buf.emit(" ").emit(loc);
				break;
			case TRUE:
				buf.emit("True ").emit(loc);
				break;
			case FALSE:
				buf.emit("False ").emit(loc);
				break;
			case NULL:
				buf.emit("Null ").emit(loc);
				break;
			}
		}
		
		private void appendObjectEntry(Located<String> key, Value<?> val) {
			String loc = Value.locToString(key.start, val.end);
			buf.emit("Pair " + loc).emit(" ").newline();
			buf.emit("[").incrIndent().newline();
			buf.emit("Key " + key.val);
			buf.emit(" ").emit(Value.locToString(key.start, key.end));
			buf.newline();
			append(val);
			buf.decrIndent().newline().emit("]");
		}
		
		static String format(@Nullable Value<?> val) {
			if (val == null) return "null";
			PrettyPrinter pp = new PrettyPrinter();
			pp.append(val);
			return pp.buf.contents();
		}
	}
	
	
	private static void testWithPos(String filename) throws IOException {
		try (Reader file = new BufferedReader(new FileReader(filename))) {
			JSonPosLexer lexer = new JSonPosLexer(filename, file);
			JSonPosParser parser = new JSonPosParser(lexer, JSonPosLexer::main);
			long start = System.nanoTime();
			JSonPosParser.Value<?> val = parser.json();
			long end = System.nanoTime();
			System.out.println("Parsed " + filename + " in " + ((end - start) / 1000000) + "ms");
			System.out.println(PrettyPrinter.format(val));
		}
		catch (ParsingException e) {
			e.printStackTrace();
		}
	}
	
	@SuppressWarnings("javadoc")
	public static void main(String args[]) throws IOException {
		testWithPos("tests/inputs/tiny.json");
		testWithPos("tests/inputs/small.json");
	}
}