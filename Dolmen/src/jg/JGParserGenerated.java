package jg;
import org.eclipse.jdt.annotation.Nullable;
import org.eclipse.jdt.annotation.NonNull;
import java.util.List;
import java.util.ArrayList;
import common.Lists;
import syntax.Extent;
import syntax.Production;
import syntax.Grammar.TokenDecl;
import syntax.GrammarRule;
import syntax.Grammar;
/**
 * Parser generated by Dolmen 
 */
@SuppressWarnings("javadoc")
@org.eclipse.jdt.annotation.NonNullByDefault({})
public final class JGParserGenerated extends codegen.BaseParser<JGParserGenerated.Token> {
    
    public static abstract class Token {
        
        public enum Kind {
            IDENT,
            ACTION,
            ARGUMENTS,
            EQUAL,
            BAR,
            DOT,
            STAR,
            SEMICOL,
            IMPORT,
            STATIC,
            PUBLIC,
            PRIVATE,
            TOKEN,
            RULE,
            EOF;
        }
        
        private Token()  {
            // nothing to do
        }
        
        @Override
        public abstract String toString();
        
        public abstract Kind getKind();
        
        public final static class IDENT extends Token {
            public final @NonNull String value;
            
            private IDENT(@NonNull String value) {
                this.value = value;
            }
            
            @Override
            public String toString() {
                return "IDENT(" + value + ")";
            }
            
            @Override
            public Kind getKind() {
                return Kind.IDENT;
            }
        }
        public static IDENT IDENT(@NonNull String value) {
            return new IDENT(value);
        }
        
        public final static class ACTION extends Token {
            public final @NonNull Extent value;
            
            private ACTION(@NonNull Extent value) {
                this.value = value;
            }
            
            @Override
            public String toString() {
                return "ACTION(" + value + ")";
            }
            
            @Override
            public Kind getKind() {
                return Kind.ACTION;
            }
        }
        public static ACTION ACTION(@NonNull Extent value) {
            return new ACTION(value);
        }
        
        public final static class ARGUMENTS extends Token {
            public final @NonNull Extent value;
            
            private ARGUMENTS(@NonNull Extent value) {
                this.value = value;
            }
            
            @Override
            public String toString() {
                return "ARGUMENTS(" + value + ")";
            }
            
            @Override
            public Kind getKind() {
                return Kind.ARGUMENTS;
            }
        }
        public static ARGUMENTS ARGUMENTS(@NonNull Extent value) {
            return new ARGUMENTS(value);
        }
        
        private static abstract class Singleton extends Token {
            private final Kind kind;
            private Singleton(Kind kind) { this.kind = kind; }
            
            @Override
            public String toString() {
                return kind.toString();
            }
            
            @Override
            public Kind getKind() {
                return kind;
            }
        }
        
        public static final Token EQUAL = new Singleton(Kind.EQUAL) {};
        public static final Token BAR = new Singleton(Kind.BAR) {};
        public static final Token DOT = new Singleton(Kind.DOT) {};
        public static final Token STAR = new Singleton(Kind.STAR) {};
        public static final Token SEMICOL = new Singleton(Kind.SEMICOL) {};
        public static final Token IMPORT = new Singleton(Kind.IMPORT) {};
        public static final Token STATIC = new Singleton(Kind.STATIC) {};
        public static final Token PUBLIC = new Singleton(Kind.PUBLIC) {};
        public static final Token PRIVATE = new Singleton(Kind.PRIVATE) {};
        public static final Token TOKEN = new Singleton(Kind.TOKEN) {};
        public static final Token RULE = new Singleton(Kind.RULE) {};
        public static final Token EOF = new Singleton(Kind.EOF) {};
    }
    
    
    /**
     * Returns {@code true} if the given string contains a lower-case letter
     */
     private static boolean isLowerId(String name) {
         return name.chars().anyMatch(ch -> Character.isLowerCase(ch));
     }

    @SuppressWarnings("null")
    public <T extends codegen.LexBuffer>JGParserGenerated(T lexbuf, java.util.function.Function<T, Token> tokens) {
        super(lexbuf, tokens);
    }
    
    private Token eat(Token.Kind kind) {
        Token ctoken = peek();
        if (kind != ctoken.getKind())
        throw tokenError(ctoken, kind);
        _jl_nextToken = null;
        return ctoken;
    }
    
    public @NonNull Grammar start() {
        
        // imports = imports(null)
        @NonNull List<@NonNull String> imports = imports(null);
        // tdecls = tokens(null)
        @NonNull List<@NonNull TokenDecl> tdecls = tokens(null);
        // header = ACTION
        @NonNull Extent header = ((Token.ACTION) eat(Token.Kind.ACTION)).value;
        // rules = rules(null)
        @NonNull List<@NonNull GrammarRule> rules = rules(null);
        // footer = ACTION
        @NonNull Extent footer = ((Token.ACTION) eat(Token.Kind.ACTION)).value;
        // EOF
        eat(Token.Kind.EOF);
        Grammar.Builder builder = new Grammar.Builder(imports, header, footer);
        tdecls.forEach(tdecl -> builder.addToken(tdecl));
        rules.forEach(rule -> builder.addRule(rule));
        return builder.build();
    }
    
    private @NonNull List<@NonNull String> imports(@Nullable List<@NonNull String> imp) {
        switch (peek().getKind()) {
            case ACTION:
            case TOKEN: {
                return imp == null ? Lists.empty() : imp;
            }
            case IMPORT: {
                @NonNull List<@NonNull String> acc = imp == null ? new ArrayList<>() : imp;
                // IMPORT
                eat(Token.Kind.IMPORT);
                // elt = import_
                String elt = import_();
                // SEMICOL
                eat(Token.Kind.SEMICOL);
                acc.add("import " + elt + ";");
                // imports(acc)
                imports(acc);
                return acc;
            }
            default: {
                throw tokenError(peek(), Token.Kind.ACTION, Token.Kind.IMPORT, Token.Kind.TOKEN);
            }
        }
    }
    
    private String import_() {
        switch (peek().getKind()) {
            case IDENT: {
                // id = IDENT
                @NonNull String id = ((Token.IDENT) eat(Token.Kind.IDENT)).value;
                // tn = typename
                String tn = typename();
                return id + tn;
            }
            case STATIC: {
                // STATIC
                eat(Token.Kind.STATIC);
                // id = IDENT
                @NonNull String id = ((Token.IDENT) eat(Token.Kind.IDENT)).value;
                // tn = typename
                String tn = typename();
                return "static " + id + tn;
            }
            default: {
                throw tokenError(peek(), Token.Kind.IDENT, Token.Kind.STATIC);
            }
        }
    }
    
    private String typename() {
        switch (peek().getKind()) {
            case DOT: {
                // DOT
                eat(Token.Kind.DOT);
                // ty = typename0
                String ty = typename0();
                return "." + ty;
            }
            case SEMICOL: {
                return "";
            }
            default: {
                throw tokenError(peek(), Token.Kind.DOT, Token.Kind.SEMICOL);
            }
        }
    }
    
    private String typename0() {
        switch (peek().getKind()) {
            case IDENT: {
                // id = IDENT
                @NonNull String id = ((Token.IDENT) eat(Token.Kind.IDENT)).value;
                // ty = typename
                String ty = typename();
                return id + ty;
            }
            case STAR: {
                // STAR
                eat(Token.Kind.STAR);
                return "*";
            }
            default: {
                throw tokenError(peek(), Token.Kind.IDENT, Token.Kind.STAR);
            }
        }
    }
    
    private @NonNull List<@NonNull TokenDecl> tokens(@Nullable List<@NonNull TokenDecl> tokens) {
        switch (peek().getKind()) {
            case ACTION: {
                return Lists.empty();
            }
            case TOKEN: {
                @NonNull List<@NonNull TokenDecl> acc = tokens == null ? new ArrayList<>() : tokens;
                // TOKEN
                eat(Token.Kind.TOKEN);
                // tok = token
                @NonNull TokenDecl tok = token();
                acc.add(tok);
                // tokens(acc)
                tokens(acc);
                return acc;
            }
            default: {
                throw tokenError(peek(), Token.Kind.ACTION, Token.Kind.TOKEN);
            }
        }
    }
    
    private @NonNull TokenDecl token() {
        switch (peek().getKind()) {
            case ACTION: {
                // val = ACTION
                @NonNull Extent val = ((Token.ACTION) eat(Token.Kind.ACTION)).value;
                // id = IDENT
                @NonNull String id = ((Token.IDENT) eat(Token.Kind.IDENT)).value;
                if (isLowerId(id))
                    throw parsingError("Token name should be all uppercase: " + id);
                return new TokenDecl(id, val);
            }
            case IDENT: {
                // id = IDENT
                @NonNull String id = ((Token.IDENT) eat(Token.Kind.IDENT)).value;
                if (isLowerId(id))
                   throw parsingError("Token name should be all uppercase: " + id);
                return new TokenDecl(id, null);
            }
            default: {
                throw tokenError(peek(), Token.Kind.ACTION, Token.Kind.IDENT);
            }
        }
    }
    
    private @NonNull List<@NonNull GrammarRule> rules(@Nullable List<@NonNull GrammarRule> rules) {
        switch (peek().getKind()) {
            case ACTION: {
                return Lists.empty();
            }
            case PRIVATE:
            case PUBLIC: {
                // rule = rule
                @NonNull GrammarRule rule = rule();
                @NonNull List<@NonNull GrammarRule> acc = rules == null ? new ArrayList<>() : rules;
                acc.add(rule);
                // rules(acc)
                rules(acc);
                return acc;
            }
            default: {
                throw tokenError(peek(), Token.Kind.ACTION, Token.Kind.PRIVATE, Token.Kind.PUBLIC);
            }
        }
    }
    
    private @NonNull GrammarRule rule() {
        
        // vis = visibility
        boolean vis = visibility();
        // rtype = ACTION
        @NonNull Extent rtype = ((Token.ACTION) eat(Token.Kind.ACTION)).value;
        // RULE
        eat(Token.Kind.RULE);
        // name = IDENT
        @NonNull String name = ((Token.IDENT) eat(Token.Kind.IDENT)).value;
        if (!Character.isLowerCase(name.charAt(0)))
            throw parsingError("Rule name must start with a lower case letter: " + name);
        // args = args
        @Nullable Extent args = args();
        // EQUAL
        eat(Token.Kind.EQUAL);
        GrammarRule.@NonNull Builder builder =
        	new GrammarRule.Builder(vis, rtype, name, args);
        // prod = production
        @NonNull Production prod = production();
        builder.addProduction(prod);
        // productions(builder)
        productions(builder);
        return builder.build();
    }
    
    private boolean visibility() {
        switch (peek().getKind()) {
            case PRIVATE: {
                // PRIVATE
                eat(Token.Kind.PRIVATE);
                return false;
            }
            case PUBLIC: {
                // PUBLIC
                eat(Token.Kind.PUBLIC);
                return true;
            }
            default: {
                throw tokenError(peek(), Token.Kind.PRIVATE, Token.Kind.PUBLIC);
            }
        }
    }
    
    private @Nullable Extent args() {
        switch (peek().getKind()) {
            case ACTION:
            case BAR:
            case EQUAL:
            case IDENT:
            case SEMICOL: {
                return null;
            }
            case ARGUMENTS: {
                // ext = ARGUMENTS
                @NonNull Extent ext = ((Token.ARGUMENTS) eat(Token.Kind.ARGUMENTS)).value;
                return ext;
            }
            default: {
                throw tokenError(peek(), Token.Kind.ACTION, Token.Kind.ARGUMENTS, Token.Kind.BAR, Token.Kind.EQUAL, Token.Kind.IDENT, Token.Kind.SEMICOL);
            }
        }
    }
    
    private void productions(GrammarRule.@NonNull Builder builder) {
        switch (peek().getKind()) {
            case BAR: {
                // prod = production
                @NonNull Production prod = production();
                builder.addProduction(prod);
                // productions(builder)
                productions(builder);
                return;
            }
            case SEMICOL: {
                // SEMICOL
                eat(Token.Kind.SEMICOL);
                return;
            }
            default: {
                throw tokenError(peek(), Token.Kind.BAR, Token.Kind.SEMICOL);
            }
        }
    }
    
    private @NonNull Production production() {
        
        // BAR
        eat(Token.Kind.BAR);
        Production.Builder builder = new Production.Builder();
        // items(builder)
        items(builder);
        return builder.build();
    }
    
    private void items(Production.Builder builder) {
        switch (peek().getKind()) {
            case ACTION: {
                // ext = ACTION
                @NonNull Extent ext = ((Token.ACTION) eat(Token.Kind.ACTION)).value;
                builder.addAction(ext);
                // items(builder)
                items(builder);
                return;
            }
            case BAR:
            case SEMICOL: {
                return;
            }
            case IDENT: {
                // id = IDENT
                @NonNull String id = ((Token.IDENT) eat(Token.Kind.IDENT)).value;
                // actual = actual(id)
                Production.@NonNull Actual actual = actual(id);
                builder.addActual(actual);
                // items(builder)
                items(builder);
                return;
            }
            default: {
                throw tokenError(peek(), Token.Kind.ACTION, Token.Kind.BAR, Token.Kind.IDENT, Token.Kind.SEMICOL);
            }
        }
    }
    
    private Production.@NonNull Actual actual(@NonNull String id) {
        switch (peek().getKind()) {
            case ACTION:
            case ARGUMENTS:
            case BAR:
            case IDENT:
            case SEMICOL: {
                // args = args
                @Nullable Extent args = args();
                return new Production.Actual(null, id, args);
            }
            case EQUAL: {
                // EQUAL
                eat(Token.Kind.EQUAL);
                // name = IDENT
                @NonNull String name = ((Token.IDENT) eat(Token.Kind.IDENT)).value;
                // args = args
                @Nullable Extent args = args();
                return new Production.Actual(id, name, args);
            }
            default: {
                throw tokenError(peek(), Token.Kind.ACTION, Token.Kind.ARGUMENTS, Token.Kind.BAR, Token.Kind.EQUAL, Token.Kind.IDENT, Token.Kind.SEMICOL);
            }
        }
    }
    
    /**
     * Testing this parser
     */
    public static void main(String[] args) throws java.io.IOException {
		String prompt;
       while ((prompt = common.Prompt.getInputLine(">")) != null) {
			try {
				JGLexer lexer = new JGLexer("-",
					new java.io.StringReader(prompt));
				JGParserGenerated parser = new JGParserGenerated(lexer, JGLexer::main);
				System.out.println(parser.start());
			} catch (ParsingException e) {
				e.printStackTrace();
			}
		}
	}

    
}
