package jg;
import org.eclipse.jdt.annotation.Nullable;
import java.util.List;
import java.util.ArrayList;
import syntax.Location;
/**
 * Parser generated by Dolmen 
 */
@SuppressWarnings("javadoc")
@org.eclipse.jdt.annotation.NonNullByDefault({})
public final class JGParserGenerated extends codegen.BaseParser<JGParserGenerated.Token> {
    
    public static abstract class Token {
        
        public enum Kind {
            IDENT,
            ACTION,
            ARGUMENTS,
            EQUAL,
            BAR,
            DOT,
            STAR,
            SEMICOL,
            IMPORT,
            STATIC,
            PUBLIC,
            PRIVATE,
            TOKEN,
            RULE,
            EOF;
        }
        
        private Token()  {
            // nothing to do
        }
        
        @Override
        public abstract String toString();
        
        public abstract Kind getKind();
        
        public final static class IDENT extends Token {
            public final String value;
            
            private IDENT(String value) {
                this.value = value;
            }
            
            @Override
            public String toString() {
                return "IDENT(" + value + ")";
            }
            
            @Override
            public Kind getKind() {
                return Kind.IDENT;
            }
        }
        public static IDENT IDENT(String value) {
            return new IDENT(value);
        }
        
        public final static class ACTION extends Token {
            public final Location value;
            
            private ACTION(Location value) {
                this.value = value;
            }
            
            @Override
            public String toString() {
                return "ACTION(" + value + ")";
            }
            
            @Override
            public Kind getKind() {
                return Kind.ACTION;
            }
        }
        public static ACTION ACTION(Location value) {
            return new ACTION(value);
        }
        
        public final static class ARGUMENTS extends Token {
            public final Location value;
            
            private ARGUMENTS(Location value) {
                this.value = value;
            }
            
            @Override
            public String toString() {
                return "ARGUMENTS(" + value + ")";
            }
            
            @Override
            public Kind getKind() {
                return Kind.ARGUMENTS;
            }
        }
        public static ARGUMENTS ARGUMENTS(Location value) {
            return new ARGUMENTS(value);
        }
        
        private static abstract class Singleton extends Token {
            private final Kind kind;
            private Singleton(Kind kind) { this.kind = kind; }
            
            @Override
            public String toString() {
                return kind.toString();
            }
            
            @Override
            public Kind getKind() {
                return kind;
            }
        }
        
        public static Token EQUAL = new Singleton(Kind.EQUAL) {};
        public static Token BAR = new Singleton(Kind.BAR) {};
        public static Token DOT = new Singleton(Kind.DOT) {};
        public static Token STAR = new Singleton(Kind.STAR) {};
        public static Token SEMICOL = new Singleton(Kind.SEMICOL) {};
        public static Token IMPORT = new Singleton(Kind.IMPORT) {};
        public static Token STATIC = new Singleton(Kind.STATIC) {};
        public static Token PUBLIC = new Singleton(Kind.PUBLIC) {};
        public static Token PRIVATE = new Singleton(Kind.PRIVATE) {};
        public static Token TOKEN = new Singleton(Kind.TOKEN) {};
        public static Token RULE = new Singleton(Kind.RULE) {};
        public static Token EOF = new Singleton(Kind.EOF) {};
    }
    
    @SuppressWarnings("null")
    public JGParserGenerated(java.util.function.Supplier<Token> tokens) {
        super(tokens);
    }
    
    private Token eat(Token.Kind kind) {
        Token ctoken = peek();
        if (kind != ctoken.getKind())
        throw tokenError(ctoken, kind);
        _jl_nextToken = null;
        return ctoken;
    }
    
    public List<String> start() {
        
        // imp = imports(null)
        List<String> imp = imports(null);
        return imp;
    }
    
    private List<String> imports(@Nullable List<String> imp) {
        
        List<String> acc = imp == null ? new ArrayList<String>() : imp;
        // IMPORT
        eat(Token.Kind.IMPORT);
        // elt = import_
        String elt = import_();
        // SEMICOL
        eat(Token.Kind.SEMICOL);
        acc.add("import " + elt + ";");
        // imports(acc)
        imports(acc);
        return acc;
    }
    
    private String import_() {
        switch (peek().getKind()) {
            case IDENT: {
                // id = IDENT
                String id = ((Token.IDENT) eat(Token.Kind.IDENT)).value;
                // tn = typename
                String tn = typename();
                return id + tn;
            }
            case STATIC: {
                // STATIC
                eat(Token.Kind.STATIC);
                // id = IDENT
                String id = ((Token.IDENT) eat(Token.Kind.IDENT)).value;
                // tn = typename
                String tn = typename();
                return "static " + id + tn;
            }
            default: {
                throw tokenError(peek(), Token.Kind.IDENT, Token.Kind.STATIC);
            }
        }
    }
    
    private String typename() {
        switch (peek().getKind()) {
            case SEMICOL: {
                return "";
            }
            case DOT: {
                // DOT
                eat(Token.Kind.DOT);
                // ty = typename0
                String ty = typename0();
                return "." + ty;
            }
            default: {
                throw tokenError(peek(), Token.Kind.SEMICOL, Token.Kind.DOT);
            }
        }
    }
    
    private String typename0() {
        switch (peek().getKind()) {
            case STAR: {
                // STAR
                eat(Token.Kind.STAR);
                return "*";
            }
            case IDENT: {
                // id = IDENT
                String id = ((Token.IDENT) eat(Token.Kind.IDENT)).value;
                // ty = typename
                String ty = typename();
                return id + ty;
            }
            default: {
                throw tokenError(peek(), Token.Kind.STAR, Token.Kind.IDENT);
            }
        }
    }
    
    /**
     * Testing this parser
     */
    public static void main(String[] args) throws java.io.IOException {
		String prompt;
       while ((prompt = common.Prompt.getInputLine(">")) != null) {
			try {
				JGLexer lexer = new JGLexer("-",
					new java.io.StringReader(prompt));
				JGParserGenerated parser = new JGParserGenerated(lexer::main);
				System.out.println(parser.start());
			} catch (ParsingException e) {
				e.printStackTrace();
			}
		}
	}

    
}
