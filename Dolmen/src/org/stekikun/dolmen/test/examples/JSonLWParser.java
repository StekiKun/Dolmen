package org.stekikun.dolmen.test.examples;

/**
 * Parser generated by Dolmen 1.0.0
 */
public final class JSonLWParser extends org.stekikun.dolmen.codegen.BaseParser<JSonLWParser.Token> {
    
    @SuppressWarnings("javadoc")
    public static abstract class Token {
        
        public enum Kind {
            LBRACKET,
            RBRACKET,
            COMMA,
            COLON,
            LSQUARE,
            RSQUARE,
            TRUE,
            FALSE,
            NULL,
            STRING,
            NUMBER,
            EOF;
        }
        
        Token(Kind kind)  {
            this.kind = kind;
        }
        private final Kind kind;
        
        @Override
        public abstract String toString();
        
        public final Kind getKind() { return kind; }
        
        public final static class STRING extends Token {
            public final  String  value;
            
            private STRING( String  value) {
                super(Kind.STRING);
                this.value = value;
            }
            
            @Override
            public String toString() {
                return "STRING(" + value + ")";
            }
        }
        public static STRING STRING( String  value) {
            return new STRING(value);
        }
        
        public final static class NUMBER extends Token {
            public final  String  value;
            
            private NUMBER( String  value) {
                super(Kind.NUMBER);
                this.value = value;
            }
            
            @Override
            public String toString() {
                return "NUMBER(" + value + ")";
            }
        }
        public static NUMBER NUMBER( String  value) {
            return new NUMBER(value);
        }
        
        private static final class Singleton extends Token {
            private Singleton(Kind kind) { super(kind); }
            
            @Override
            public String toString() {
                return getKind().toString();
            }
        }
        
        public static final Token LBRACKET = new Singleton(Kind.LBRACKET);
        public static final Token RBRACKET = new Singleton(Kind.RBRACKET);
        public static final Token COMMA = new Singleton(Kind.COMMA);
        public static final Token COLON = new Singleton(Kind.COLON);
        public static final Token LSQUARE = new Singleton(Kind.LSQUARE);
        public static final Token RSQUARE = new Singleton(Kind.RSQUARE);
        public static final Token TRUE = new Singleton(Kind.TRUE);
        public static final Token FALSE = new Singleton(Kind.FALSE);
        public static final Token NULL = new Singleton(Kind.NULL);
        public static final Token EOF = new Singleton(Kind.EOF);
    }
    
    
    

    /**
     * Builds a new parser based on the given lexical buffer
     * and tokenizer
     * @param lexbuf
     * @param tokens
     */
    public <T extends org.stekikun.dolmen.codegen.LexBuffer> 
        JSonLWParser(T lexbuf, java.util.function.Function<T, Token> tokens) {
        super(lexbuf, tokens);
    }
    
    private Token eat(Token.Kind kind) {
        Token ctoken = eat();
        if (kind != ctoken.getKind())
            throw tokenError(ctoken, kind);
        return ctoken;
    }
    
    /**
     * Entry point for the non-terminal json
     */
    public  void  json() {
        // value
        value();
        // EOF
        eat(Token.Kind.EOF);
         return; 
    }
    
    private  void  value() {
        switch (peek().getKind()) {
            case FALSE: {
                // FALSE
                eat(Token.Kind.FALSE);
                 return; 
            }
            case LBRACKET: {
                // object
                object();
                 return; 
            }
            case LSQUARE: {
                // array
                array();
                 return; 
            }
            case NULL: {
                // NULL
                eat(Token.Kind.NULL);
                 return; 
            }
            case NUMBER: {
                // NUMBER
                eat(Token.Kind.NUMBER);
                 return; 
            }
            case STRING: {
                // STRING
                eat(Token.Kind.STRING);
                 return; 
            }
            case TRUE: {
                // TRUE
                eat(Token.Kind.TRUE);
                 return; 
            }
            default: {
                throw tokenError(peek(), Token.Kind.FALSE, Token.Kind.LBRACKET, Token.Kind.LSQUARE, Token.Kind.NULL, Token.Kind.NUMBER, Token.Kind.STRING, Token.Kind.TRUE);
            }
        }
    }
    
    private  void  array() {
        // LSQUARE
        eat(Token.Kind.LSQUARE);
        // elements
        elements();
         return; 
    }
    
    private  void  elements() {
        switch (peek().getKind()) {
            case FALSE:
            case LBRACKET:
            case LSQUARE:
            case NULL:
            case NUMBER:
            case STRING:
            case TRUE: {
                // value
                value();
                // more_elements
                more_elements();
                 return; 
            }
            case RSQUARE: {
                // RSQUARE
                eat(Token.Kind.RSQUARE);
                 return; 
            }
            default: {
                throw tokenError(peek(), Token.Kind.FALSE, Token.Kind.LBRACKET, Token.Kind.LSQUARE, Token.Kind.NULL, Token.Kind.NUMBER, Token.Kind.RSQUARE, Token.Kind.STRING, Token.Kind.TRUE);
            }
        }
    }
    
    private  void  more_elements() {
        more_elements:
        while (true) {
            switch (peek().getKind()) {
                case COMMA: {
                    // COMMA
                    eat(Token.Kind.COMMA);
                    // value
                    value();
                    continue more_elements;
                }
                case RSQUARE: {
                    // RSQUARE
                    eat(Token.Kind.RSQUARE);
                     return; 
                }
                default: {
                    throw tokenError(peek(), Token.Kind.COMMA, Token.Kind.RSQUARE);
                }
            }
        }
    }
    
    private  void  object() {
        // LBRACKET
        eat(Token.Kind.LBRACKET);
        // members
        members();
         return; 
    }
    
    private  void  members() {
        switch (peek().getKind()) {
            case RBRACKET: {
                // RBRACKET
                eat(Token.Kind.RBRACKET);
                 return; 
            }
            case STRING: {
                // pair
                pair();
                // more_members
                more_members();
                 return; 
            }
            default: {
                throw tokenError(peek(), Token.Kind.RBRACKET, Token.Kind.STRING);
            }
        }
    }
    
    private  void  more_members() {
        more_members:
        while (true) {
            switch (peek().getKind()) {
                case COMMA: {
                    // COMMA
                    eat(Token.Kind.COMMA);
                    // pair
                    pair();
                    continue more_members;
                }
                case RBRACKET: {
                    // RBRACKET
                    eat(Token.Kind.RBRACKET);
                     return; 
                }
                default: {
                    throw tokenError(peek(), Token.Kind.COMMA, Token.Kind.RBRACKET);
                }
            }
        }
    }
    
    private  void  pair() {
        // STRING
        eat(Token.Kind.STRING);
        // COLON
        eat(Token.Kind.COLON);
        // value
        value();
         return; 
    }
    
     
    
}
