package org.stekikun.dolmen.test.examples;
import java.util.Optional;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;

/**
 * Parser generated by Dolmen 1.0.0
 */
@SuppressWarnings("unused")
public final class Templates extends org.stekikun.dolmen.codegen.BaseParser<Templates.Token> {
    
    @SuppressWarnings("javadoc")
    public static abstract class Token {
        
        public enum Kind {
            STRING,
            COMMA,
            LPAREN,
            RPAREN;
        }
        
        Token(Kind kind)  {
            this.kind = kind;
        }
        private final Kind kind;
        
        @Override
        public abstract String toString();
        
        public final Kind getKind() { return kind; }
        
        public final static class STRING extends Token {
            public final  String  value;
            
            private STRING( String  value) {
                super(Kind.STRING);
                this.value = value;
            }
            
            @Override
            public String toString() {
                return "STRING(" + value + ")";
            }
        }
        public static STRING STRING( String  value) {
            return new STRING(value);
        }
        
        private static final class Singleton extends Token {
            private Singleton(Kind kind) { super(kind); }
            
            @Override
            public String toString() {
                return getKind().toString();
            }
        }
        
        public static final Token COMMA = new Singleton(Kind.COMMA);
        public static final Token LPAREN = new Singleton(Kind.LPAREN);
        public static final Token RPAREN = new Singleton(Kind.RPAREN);
    }
    
    
     
    /**
     * Builds a new parser based on the given lexical buffer
     * and tokenizer
     * @param lexbuf
     * @param tokens
     */
    public <T extends org.stekikun.dolmen.codegen.LexBuffer> 
        Templates(T lexbuf, java.util.function.Function<T, Token> tokens) {
        super("1.0.0", lexbuf, tokens);
    }
    
    private Token eat(Token.Kind kind) {
        Token ctoken = eat();
        if (kind != ctoken.getKind())
            throw tokenError(ctoken, kind);
        return ctoken;
    }
    
    private   List< String >   loptionˎseparated_nelistˎCOMMAˌSTRINGˏˏ() {
        switch (peek().getKind()) {
            case RPAREN: {
                 return Collections.emptyList(); 
            }
            case STRING: {
                // v = separated_nelist<COMMA, STRING>
                 List< String >  v = separated_nelistˎCOMMAˌSTRINGˏ();
                 return v; 
            }
            //$CASES-OMITTED$
            default: {
                throw tokenError(peek(), Token.Kind.RPAREN, Token.Kind.STRING);
            }
        }
    }
    
    private   List< String >   enclosedˎLPARENˌseparated_listˎCOMMAˌSTRINGˏˌRPARENˏ() {
        // LPAREN
        eat(Token.Kind.LPAREN);
        // c = separated_list<COMMA, STRING>
         List< String >  c = separated_listˎCOMMAˌSTRINGˏ();
        // RPAREN
        eat(Token.Kind.RPAREN);
         return c; 
    }
    
    private  List<  List< String >  >  listˎenclosedˎLPARENˌseparated_listˎCOMMAˌSTRINGˏˌRPARENˏˏ() {
        // v = enclosed<LPAREN, separated_list<COMMA, STRING>, RPAREN>
          List< String >   v = enclosedˎLPARENˌseparated_listˎCOMMAˌSTRINGˏˌRPARENˏ();
         List<  List< String >  > acc = new ArrayList<>(); acc.add(v); 
        // more_list<enclosed<LPAREN, separated_list<COMMA, STRING>, RPAREN>>(acc)
        more_listˎenclosedˎLPARENˌseparated_listˎCOMMAˌSTRINGˏˌRPARENˏˏ(acc);
         return acc; 
    }
    
    private  void  more_listˎenclosedˎLPARENˌseparated_listˎCOMMAˌSTRINGˏˌRPARENˏˏ(List<  List< String >  > acc) {
        more_listˎenclosedˎLPARENˌseparated_listˎCOMMAˌSTRINGˏˌRPARENˏˏ:
        while (true) {
            // v = enclosed<LPAREN, separated_list<COMMA, STRING>, RPAREN>
              List< String >   v = enclosedˎLPARENˌseparated_listˎCOMMAˌSTRINGˏˌRPARENˏ();
             acc.add(v); 
            continue more_listˎenclosedˎLPARENˌseparated_listˎCOMMAˌSTRINGˏˌRPARENˏˏ;
        }
        
    }
    
    private  List< String >  separated_listˎCOMMAˌSTRINGˏ() {
        // l = loption<separated_nelist<COMMA, STRING>>
          List< String >   l = loptionˎseparated_nelistˎCOMMAˌSTRINGˏˏ();
         return l; 
    }
    
    private  List< String >  separated_nelistˎCOMMAˌSTRINGˏ() {
        // v = STRING
         String  v = ((Token.STRING) eat(Token.Kind.STRING)).value;
         List< String > acc = new ArrayList<>(); acc.add(v); 
        // more_separated_list<COMMA, STRING>(acc)
        more_separated_listˎCOMMAˌSTRINGˏ(acc);
         return acc; 
    }
    
    private  void  more_separated_listˎCOMMAˌSTRINGˏ(List< String > acc) {
        more_separated_listˎCOMMAˌSTRINGˏ:
        while (true) {
            switch (peek().getKind()) {
                case COMMA: {
                    // COMMA
                    eat(Token.Kind.COMMA);
                    // v = STRING
                     String  v = ((Token.STRING) eat(Token.Kind.STRING)).value;
                     acc.add(v); 
                    continue more_separated_listˎCOMMAˌSTRINGˏ;
                }
                case RPAREN: {
                     return; 
                }
                //$CASES-OMITTED$
                default: {
                    throw tokenError(peek(), Token.Kind.COMMA, Token.Kind.RPAREN);
                }
            }
        }
    }
    
    /**
     * Entry point for the non-terminal foo1
     */
    public  void  foo1() {
        // list<enclosed<LPAREN, separated_list<COMMA, STRING>, RPAREN>>
        listˎenclosedˎLPARENˌseparated_listˎCOMMAˌSTRINGˏˌRPARENˏˏ();
    }
    
     
    
}
