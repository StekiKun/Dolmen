package org.stekikun.dolmen.test.regular;

import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.jdt.annotation.Nullable;
import org.stekikun.dolmen.common.CSet;
import org.stekikun.dolmen.common.Generator;
import org.stekikun.dolmen.syntax.Regular;
import org.stekikun.dolmen.syntax.Regulars;
import org.stekikun.dolmen.syntax.Regulars.VarsInfo;
import org.stekikun.dolmen.tagged.Encoder;
import org.stekikun.dolmen.tagged.TRegular;
import org.stekikun.dolmen.tagged.TRegulars;
import org.stekikun.dolmen.tagged.TRegular.TagInfo;
import org.stekikun.dolmen.test.TestUnit;

/**
 * Testing unit which generates matchers for tagged regular
 * expressions using {@link TRegulars#witnesses} and
 * checks them using {@link TRegulars#matches(List, TRegular, String)}.
 * 
 * @author Stéphane Lescuyer
 */
public final class TestGenerateTMatchers
	implements TestUnit<Regular, TestGenerateTMatchers.Result> {

	/**
	 * The result of each of these tests, regrouping
	 * the result of encoding the sampled regular expression
	 * into a tagged one, the associated character sets, 
	 * and a set of matchers generated by 
	 * {@link TRegulars#witnesses(List, TRegular)}.
	 * 
	 * @author Stéphane Lescuyer
	 */
	public final static class Result {
		final List<CSet> charSets;
		final TRegular tagged;
		final Set<String> matchers;
		
		Result(List<CSet> charSets, TRegular tagged, Set<String> matchers) {
			this.charSets = charSets;
			this.tagged = tagged;
			this.matchers = matchers;
		}
		
		@Override
		public String toString() {
			return "{ charSets=" + charSets + ", "
				+ "tagged=" + tagged + ", matchers="
				+ matchers + " }";
		}
	}
	
	private final int maxSamples;
	
	/**
	 * Returns a new instance of this test unit,
	 * which tests at most {@code maxSamples} 
	 * matchers per regular expression
	 * 
	 * @param maxSamples
	 */
	public TestGenerateTMatchers(int maxSamples) {
		this.maxSamples = maxSamples;
	}

	@Override
	public String name() {
		return "Testing that matchers generated by TRegulars.witnesses " 
				+ "are indeed verified by TRegulars.matches";
	}

	@Override
	public Generator<Regular> generator() {
		return Regular.generator();
	}

	@Override
	public Result apply(Regular input) {
		Encoder encoder = new Encoder(true);
		VarsInfo varsInfo = Regulars.analyseVars(input);
		final Set<String> charVars = varsInfo.getCharVars();
		
		TRegular treg = encoder.encode(input, charVars, 0);
		List<CSet> charSets = encoder.getCharacterSets();
		int maxTries = 10 * maxSamples;
		int found = 0;
		Set<String> res = new HashSet<String>();
		for (String matcher : TRegulars.witnesses(charSets, treg)) {
			if (--maxTries < 0) break;
			if (res.add(matcher))
				if (++found == maxSamples) break;
		}
		return new Result(charSets, treg, res);
	}

	@Override
	public @Nullable String check(Regular input, Result output) {
		final List<CSet> charSets = output.charSets;
		for (String matcher : output.matchers) {
			@Nullable Map<TagInfo, Integer> check =
				TRegulars.matches(charSets, output.tagged, matcher);
			if (check == null) {
				StringBuilder buf = new StringBuilder();
				buf.append("String [").append(matcher)
				   .append("] does not match tagged regexp ")
				   .append(output.tagged).append(" wrt ")
				   .append(charSets);
				return buf.toString();
			}
		}
		return null;
	}

}